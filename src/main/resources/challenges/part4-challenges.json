{
  "partNumber": 4,
  "partTitle": "Advanced Kotlin",
  "challenges": [
    {
      "id": "4.1.1",
      "lessonId": "4.1",
      "title": "Simple Lambda",
      "description": "Create a lambda that takes two integers and returns their sum. Store it in a variable and call it.",
      "difficulty": 2,
      "starterCode": "fun main() {\n    // Create a lambda that adds two numbers\n    val add = \n    \n    println(add(5, 3))  // Should print 8\n}",
      "solution": "fun main() {\n    val add = { a: Int, b: Int -> a + b }\n    \n    println(add(5, 3))  // Should print 8\n}",
      "hints": [
        "Lambda syntax: { parameters -> body }",
        "Specify parameter types: a: Int, b: Int",
        "Return value is the last expression",
        "Store lambda in a variable"
      ],
      "testCases": [
        {
          "description": "Lambda should add 5 and 3",
          "expectedOutput": "8",
          "points": 10
        }
      ]
    },
    {
      "id": "4.1.2",
      "lessonId": "4.1",
      "title": "Higher-Order Function",
      "description": "Create a function `applyOperation` that takes two integers and a lambda operation, then returns the result of applying the operation.",
      "difficulty": 3,
      "starterCode": "fun applyOperation(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n    // Apply the operation to a and b\n}\n\nfun main() {\n    val result1 = applyOperation(10, 5) { x, y -> x + y }\n    val result2 = applyOperation(10, 5) { x, y -> x * y }\n    println(\"Addition: $result1\")\n    println(\"Multiplication: $result2\")\n}",
      "solution": "fun applyOperation(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n    return operation(a, b)\n}\n\nfun main() {\n    val result1 = applyOperation(10, 5) { x, y -> x + y }\n    val result2 = applyOperation(10, 5) { x, y -> x * y }\n    println(\"Addition: $result1\")\n    println(\"Multiplication: $result2\")\n}",
      "hints": [
        "Function parameter type: (Int, Int) -> Int",
        "Call the lambda like a function: operation(a, b)",
        "Lambda can be passed as the last parameter outside parentheses"
      ],
      "testCases": [
        {
          "description": "Addition should work",
          "expectedOutput": "Addition: 15",
          "points": 5
        },
        {
          "description": "Multiplication should work",
          "expectedOutput": "Multiplication: 50",
          "points": 5
        }
      ]
    },
    {
      "id": "4.1.3",
      "lessonId": "4.1",
      "title": "Filter and Map",
      "description": "Given a list of numbers, filter out even numbers, then multiply each by 2 using map.",
      "difficulty": 2,
      "starterCode": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    // Filter odd numbers and multiply by 2\n    val result = \n    \n    println(result)\n}",
      "solution": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    val result = numbers\n        .filter { it % 2 != 0 }\n        .map { it * 2 }\n    \n    println(result)\n}",
      "hints": [
        "Use filter to keep only odd numbers (it % 2 != 0)",
        "Use map to transform each element",
        "Chain operations with .",
        "Use 'it' for single parameter lambdas"
      ],
      "testCases": [
        {
          "description": "Should filter odd numbers and double them",
          "expectedOutput": "[2, 6, 10, 14, 18]",
          "points": 10
        }
      ]
    },
    {
      "id": "4.2.1",
      "lessonId": "4.2",
      "title": "Extension Function",
      "description": "Create an extension function on String called `isPalindrome()` that returns true if the string reads the same forwards and backwards.",
      "difficulty": 3,
      "starterCode": "// Create extension function here\n\nfun main() {\n    println(\"racecar\".isPalindrome())  // Should be true\n    println(\"hello\".isPalindrome())    // Should be false\n    println(\"madam\".isPalindrome())    // Should be true\n}",
      "solution": "fun String.isPalindrome(): Boolean {\n    return this == this.reversed()\n}\n\nfun main() {\n    println(\"racecar\".isPalindrome())  // Should be true\n    println(\"hello\".isPalindrome())    // Should be false\n    println(\"madam\".isPalindrome())    // Should be true\n}",
      "hints": [
        "Extension function syntax: fun Type.functionName()",
        "Use 'this' to refer to the receiver object",
        "Use reversed() method on String",
        "Compare original with reversed using =="
      ],
      "testCases": [
        {
          "description": "racecar should be palindrome",
          "expectedOutput": "true",
          "points": 4
        },
        {
          "description": "hello should not be palindrome",
          "expectedOutput": "false",
          "points": 3
        },
        {
          "description": "madam should be palindrome",
          "expectedOutput": "true",
          "points": 3
        }
      ]
    },
    {
      "id": "4.2.2",
      "lessonId": "4.2",
      "title": "Extension Function on List",
      "description": "Create an extension function on List<Int> called `secondLargest()` that returns the second largest number or null if list has fewer than 2 elements.",
      "difficulty": 4,
      "starterCode": "fun List<Int>.secondLargest(): Int? {\n    // Your implementation\n}\n\nfun main() {\n    println(listOf(5, 2, 8, 1, 9).secondLargest())  // Should be 8\n    println(listOf(10).secondLargest())              // Should be null\n}",
      "solution": "fun List<Int>.secondLargest(): Int? {\n    if (this.size < 2) return null\n    val sorted = this.sortedDescending()\n    return sorted[1]\n}\n\nfun main() {\n    println(listOf(5, 2, 8, 1, 9).secondLargest())  // Should be 8\n    println(listOf(10).secondLargest())              // Should be null\n}",
      "hints": [
        "Check list size first",
        "Use sortedDescending() to sort in descending order",
        "Second largest is at index 1 after sorting",
        "Return null for lists with < 2 elements"
      ],
      "testCases": [
        {
          "description": "Should find second largest",
          "expectedOutput": "8",
          "points": 6
        },
        {
          "description": "Should return null for small lists",
          "expectedOutput": "null",
          "points": 4
        }
      ]
    },
    {
      "id": "4.3.1",
      "lessonId": "4.3",
      "title": "Partition a List",
      "description": "Use the partition function to split a list of numbers into even and odd numbers.",
      "difficulty": 2,
      "starterCode": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    // Use partition to split into even and odd\n    val (even, odd) = \n    \n    println(\"Even: $even\")\n    println(\"Odd: $odd\")\n}",
      "solution": "fun main() {\n    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    val (even, odd) = numbers.partition { it % 2 == 0 }\n    \n    println(\"Even: $even\")\n    println(\"Odd: $odd\")\n}",
      "hints": [
        "partition returns a Pair of two lists",
        "Use destructuring: val (first, second) = pair",
        "Predicate for even: it % 2 == 0",
        "True values go to first list, false to second"
      ],
      "testCases": [
        {
          "description": "Even numbers should be extracted",
          "expectedOutput": "Even: [2, 4, 6, 8, 10]",
          "points": 5
        },
        {
          "description": "Odd numbers should be extracted",
          "expectedOutput": "Odd: [1, 3, 5, 7, 9]",
          "points": 5
        }
      ]
    },
    {
      "id": "4.3.2",
      "lessonId": "4.3",
      "title": "Sequence for Large Data",
      "description": "Create a sequence that generates the first 10 squares of numbers, but only compute when needed.",
      "difficulty": 3,
      "starterCode": "fun main() {\n    // Create a sequence of squares\n    val squares = \n    \n    // Take first 5\n    println(squares.take(5).toList())\n}",
      "solution": "fun main() {\n    val squares = generateSequence(1) { it + 1 }\n        .map { it * it }\n    \n    println(squares.take(5).toList())\n}",
      "hints": [
        "Use generateSequence to create infinite sequence",
        "First parameter is the initial value",
        "Second parameter is lambda that generates next value",
        "Use map to compute squares",
        "Use take() to limit results"
      ],
      "testCases": [
        {
          "description": "Should generate first 5 squares",
          "expectedOutput": "[1, 4, 9, 16, 25]",
          "points": 10
        }
      ]
    }
  ]
}
